<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
	Documentation for Lua Lanes
-->

<html>
<head>
	<meta name="description" content="Lua Lanes - multithreading in Lua" />
	<meta name="keywords" content="Lua, Library, Multithreading, Threads, Rocks" />

	<title>Lua Lanes - multithreading in Lua</title>
</head>

<body>

<div class="header">
	<hr/>

	<center>
		<table summary="Lua logo"><tbody>
			<tr>
				<td align="center">
					<a href="http://www.lua.org">
						<img src="multi.png" alt="Lua" align="middle" border="0" height="120" width="128" />
						<img src="multi.png" alt="Lua" align="middle" border="0" height="120" width="128" />
						<img src="multi.png" alt="Lua" align="middle" border="0" height="120" width="128" />
						<img src="multi.png" alt="Lua" align="middle" border="0" height="120" width="128" />
						<img src="multi.png" alt="Lua" align="middle" border="0" height="120" width="128" />
					</a>
				</td>
			</tr>
			<tr>
				<td align="center" valign="top"><h1>Lua Lanes - multithreading in Lua</h1></td>
			</tr>
		</tbody></table>

		<p class="bar">
			<a href="#description">Description</a> &middot;
			<a href="#systems">Supported systems</a> &middot;
			<a href="#installing">Building and Installing</a> &middot;
			<a href="#embedding">Embedding</a>
		</p>

		<p class="bar">
			<a href="#creation">Creation</a> &middot;
			<a href="#status">Status</a> &middot;
			<a href="#results">Results and errors</a>
		</p>

		<p class="bar">
			<a href="#cancelling">Cancelling</a> &middot;
			<a href="#finalizers">Finalizers</a> &middot;
			<a href="#lindas">Lindas</a> &middot;
			<a href="#timers">Timers</a> &middot;
			<a href="#locks">Locks etc.</a>
		</p>

		<p class="bar">
			<a href="#other">Other issues</a> &middot;
			<a href="#changes">Change log</a>
		</p>
		<!-- ... -->

		<font size="-1">
			<p>
				<br/>
				<i>Copyright &copy; 2007-22 Asko Kauppi, Benoit Germain. All rights reserved.</i>
				<br/>
				Lua Lanes is published under the same <a href="http://en.wikipedia.org/wiki/MIT_License">MIT license</a> as Lua 5.1, 5.2, 5.3 and 5.4.
			</p>

			<p>
				This document was revised on 8-Feb-22, and applies to version <tt>3.16.0</tt>.
			</p>
		</font>
	</center>
</div>


<!-- description +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>
<h2 id="description">Description</h2>

<p>
	Lua Lanes is a Lua extension library providing the possibility to run multiple Lua states in parallel. It is intended to be used for optimizing performance on multicore CPU's and to study ways to make Lua programs naturally parallel to begin with.
</p>
<p>
	Lanes is included into your software by the regular <tt>require "lanes"</tt> method. No C side programming is needed; all APIs are Lua side, and most existing extension modules should work seamlessly together with the multiple lanes.
</p>
<p>
	Starting with version 3.1.6, Lanes should build and run identically with either Lua 5.1 or Lua 5.2. Version 3.10.0 supports Lua 5.3.
</p>
<p>
	See <A HREF="comparison.html">comparison</A> of Lua Lanes with other Lua multithreading solutions.
</p>
<p>
	<h3>Features:</h3>

	<ul>
		<li>Lanes have separated data, by default. Shared data is possible with Linda objects.</li>
		<li>Communications is separate of threads, using Linda objects.</li>
		<li>Data passing uses fast inter-state copies (no serialization required).</li>
		<li>"Deep userdata" concept, for sharing userdata over multiple lanes.</li>
		<li>Millisecond level timers, integrated with the Linda system.</li>
		<li>Threads can be given priorities.</li>
		<li>Lanes are cancellable, with proper cleanup.</li>
		<li>No Lua-side application level locking - ever!</li>
		<li>Several totally independant Lanes universes may coexist in an application, one per "master" Lua state.</li>
	</ul>


	<h3 id="limitations">Limitations:</h3>

	<ul>
		<li>Coroutines are not passed between states.</li>
		<li>Sharing full userdata between states needs special C side preparations (-&gt; <A HREF="#deep_userdata">deep userdata</A> and -&gt; <A HREF="#clonable_userdata">clonable userdata</A>).</li>
		<li>Network level parallelism not included.</li>
		<li>Multi-CPU is done with OS threads, not processes. A lane is a Lua full userdata, therefore it will exist only as long as the Lua state that created it still exists. Therefore, a lane won't continue execution after the main program's termination.</li>
		<li>Just like independant Lua states, Lanes universes cannot communicate together.</li>
	</ul>
</p>


<!-- systems +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>
<h2 id="systems">Supported systems</h2>

<p>
	Lua Lanes supports the following operating systems:

	<ul>
		<li>Mac OS X PowerPC / Intel (10.4 and later)</li>
		<li>Linux x86</li>
		<li>Openwrt (15.05 and later)</li>
		<li>Windows 2000/XP and later <font size="-1">(MinGW or Visual C++ 2005/2008)</font></li>
<!--
	Other OS'es here once people help test them. (and the tester's name)

	Win64, BSD, Linux x64, Linux embedded, QNX, Solaris, ...
-->
	</ul>

</p>
<p>
	The underlying threading code can be compiled either towards Win32 API or <a TARGET="_blank" HREF="http://en.wikipedia.org/wiki/POSIX_Threads">Pthreads</a>. Unfortunately, thread prioritization under Pthreads is a JOKE,
	requiring OS specific tweaks and guessing undocumented behaviour. Other features should be portable to any modern platform.
</p>


<!-- installing +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>
<h2 id="installing">Building and Installing</h2>

<p>
	Lua Lanes is built simply by <tt>make</tt> on the supported platforms (<tt>make-vc</tt> for Visual C++). See <tt>README</tt> for system specific details and limitations.
</p>

<p>
	To install Lanes, all you need are the <tt>lanes.lua</tt> and <tt>lanes/core.so|dll</tt> files to be reachable by Lua (see LUA_PATH, LUA_CPATH).
	Or use <A HREF="http://www.luarocks.org" TARGET="_blank">Lua Rocks</A> package management.
</p>

<pre>
	> luarocks search lanes
	... output listing Lua Lanes is there ...

	> luarocks install lanes
	... output ...
</pre>


<!-- embedding +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>
<h2 id="embedding">Embedding</h2>
<p>
	When Lanes is embedded, it is possible to statically initialize with
</p>
<table border=1 bgcolor="#E0E0FF" cellpadding="10" style="width:50%">
	<tr>
		<td>
			<pre>	extern void LANES_API luaopen_lanes_embedded( lua_State* L, lua_CFunction _luaopen_lanes);</pre>
		</td>
	</tr>
</table>
<p>
	<tt>luaopen_lanes_embedded</tt> leaves the module table on the stack. <tt>lanes.configure()</tt> must still be called in order to use Lanes.
	<br/>
	If <tt>_luaopen_lanes</tt> is <tt>NULL</tt>, a default loader will simply attempt the equivalent of <tt>luaL_dofile( L, "lanes.lua")</tt>.
</p>

<p>
	To embed Lanes, compile source files in you application. In any Lua state were you want to use Lanes, initialize it as follows:
</p>

<p>
	<table border="1" bgcolor="#FFFFE0" cellpadding="10" style="width:50%">
	<tr>
			<td>
				<pre>	#include "lanes.h"</pre>
				<br/>
				<pre>	int load_lanes_lua( lua_State* L)</pre>
				<pre>	{</pre>
				<pre>		// retrieve lanes.lua from wherever it is stored and return the result of its execution</pre>
				<pre>		// trivial example 1:</pre>
				<pre>		luaL_dofile( L, "lanes.lua");</pre>
				<br/>
				<pre>		// trivial example 2:</pre>
				<pre>		luaL_dostring( L, bin2c_lanes_lua);</pre>
				<pre>	}</pre>
				<br/>
				<pre>	void embed_lanes( lua_State* L)</pre>
				<pre>	{</pre>
				<pre>		// we need base libraries for Lanes for work</pre>
				<pre>		luaL_openlibs( L);</pre>
				<pre>		...</pre>
				<pre>		// will attempt luaL_dofile( L, "lanes.lua");</pre>
				<pre>		luaopen_lanes_embedded( L, NULL);</pre>
				<pre>		lua_pop( L, 1);</pre>
				<pre>		// another example with a custom loader</pre>
				<pre>		luaopen_lanes_embedded( L, load_lanes_lua);</pre>
				<pre>		lua_pop( L, 1);</pre>
				<br/>
				<pre>		// a little test to make sure things work as expected</pre>
				<pre>		luaL_dostring( L, "local lanes = require 'lanes'.configure{with_timers = false}; local l = lanes.linda()");</pre>
				<pre>	}</pre>
			</td>
		</tr>
	</table>
</p>

<!-- launching +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>

<h2 id="initialization">Initialization</h2>

<p>
	The following sample shows how to initialize the Lanes module.
</p>

<table border="1" bgcolor="#FFFFE0" cellpadding="10" style="width:50%">
	<tr>
		<td>
			<pre>	local lanes = require "lanes".configure()</pre>
		</td>
	</tr>
</table>

<p>
	Starting with version 3.0-beta, requiring the module follows Lua 5.2 rules: the module is not available under the global name "lanes", but has to be accessed through <tt>require</tt>'s return value.
</p>
<p>
	After lanes is required, it is necessary to call <tt>lanes.configure()</tt>, which is the only function exposed by the module at this point. Calling <tt>configure()</tt> will perform one-time initializations and make the rest of the API available.
</p>
<p>
	At the same time, <tt>configure()</tt> itself will be replaced by another function that raises an error if called again with differing arguments, if any.
</p>
<p>
	Also, once Lanes is initialized, <tt>require()</tt> is replaced by another one that wraps it inside a mutex, both in the main state and in all created lanes. This prevents multiple thread-unsafe module initializations from several lanes to occur simultaneously.
	It remains to be seen whether this is actually useful or not: If a module is already threadsafe, protecting its initialization isn't useful. And if it is not, any parallel operation may crash without Lanes being able to do anything about it.
</p>
<p>
	<b>IMPORTANT NOTE:</b> Starting with version 3.7.0, only the first occurence of <tt>require "lanes"</tt> must be followed by a call to <tt>.configure()</tt>. From this point, a simple <tt>require "lanes"</tt> will do wherever you need to require lanes again.
</p>

<p>
	<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%">
		<tr>
			<td>
				<pre>	lanes.configure( [opt_tbl])</pre>
			</td>
		</tr>
	</table>
</p>

<p>
	<tt>lanes.configure</tt> accepts an optional options table as sole argument.
	<table border="1" cellpadding="10" style="width:100%">
		<tr>
			<th style="width:15%">name</th>
			<th style="width:15%">value</th>
			<th style="width:70%">definition</th>
		</tr>
		<tr valign=top>
			<td id="nb_keepers">
				<code>.nb_keepers</code>
			</td>
			<td>integer >= 1</td>
			<td>
				Controls the number of keeper states used internally by lindas to transfer data between lanes. (see <a href="#lindas">below</a>). Default is <tt>1</tt>.
			</td>
		</tr>

		<tr valign=top>
			<td id="with_timers">
				<code>.with_timers</code>
			</td>
			<td>
				<tt>nil</tt>/<tt>false</tt>/<tt>true</tt>
			</td>
			<td>
				If equal to <tt>false</tt> or <tt>nil</tt>, Lanes doesn't start the timer service, and the associated API will be absent from the interface (see below).
				Default is <tt>true</tt>.
			</td>
		</tr>

		<tr valign=top>
			<td id="verbose_errors">
				<code>.verbose_errors</code>
			</td>
			<td>
				<tt>nil</tt>/<tt>false</tt>/<tt>true</tt>
			</td>
			<td>
				(Since v3.6.3) If equal to <tt>true</tt>, Lanes will collect more information when transfering stuff across Lua states to help identify errors (with a cost).
				Default is <tt>false</tt>.
			</td>
		</tr>

		<tr valign=top>
			<td id="protect_allocator">
				<code>.protect_allocator</code>
			</td>
			<td>
				<tt>nil</tt>/<tt>false</tt>/<tt>true</tt>
			</td>
			<td>
				REPLACED BY <tt>allocator="protected"</tt> AS OF VERSION v3.13.0.
				(Since v3.5.2) If equal to <tt>true</tt>, Lanes wraps all calls to the state's allocator function inside a mutex. Since v3.6.3, when left unset, Lanes attempts to autodetect this value for LuaJIT (the guess might be wrong if <tt>"ffi"</tt> isn't loaded though).
				Default is <tt>true</tt> when Lanes detects it is run by LuaJIT, else <tt>nil</tt>.
			</td>
		</tr>

		<tr valign=top>
			<td id="allocator">
				<code>.allocator</code>
			</td>
			<td>
				<tt>nil</tt>/<tt>"protected"</tt>/function
			</td>
			<td>
				(Since v3.13.0)<br/>
				If <tt>nil</tt>, Lua states are created with <tt>lua_newstate()</tt> and reuse the allocator from the master state.<br/>
				If <tt>"protected"</tt>, The default allocator obtained from <tt>lua_getallocf()</tt> in the master state is wrapped inside a critical section and used in all newly created states.<br/>
				If a <tt>function</tt>, this function is called prior to creating the state. It should return a full userdata containing the following structure:
				<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%">
					<tr>
						<td>
							<pre>	struct { lua_Alloc allocF; void* allocUD;}</pre>
						</td>
					</tr>
				</table>
				The contents will be used to create the state with <tt>lua_newstate( allocF, allocUD)</tt>.
				This option is mostly useful for embedders that want to provide different allocators to each lane, for example to have each one work in a different memory pool thus preventing the need for the allocator itself to be threadsafe.
				Note however that linda deep proxy are allocated with the allocator from the master state, because they are not tied to a particular state.
			</td>
		</tr>

		<tr valign=top>
			<td id="demote_full_userdata">
				<code>.demote_full_userdata</code>
			</td>
			<td>
				<tt>nil</tt>/<tt>false</tt>/<tt>true</tt>
			</td>
			<td>
				(Since v3.7.5) If equal to <tt>false</tt> or <tt>nil</tt>, Lanes raises an error when attempting to transfer a non-deep full userdata, else it will be demoted to a light userdata in the destination.
				Default is <tt>false</tt> (set to <tt>true</tt> to get the legacy behaviour).
			</td>
		</tr>

		<tr valign=top>
			<td id="track_lanes">
				<code>.track_lanes</code>
			</td>
			<td>
				<tt>nil</tt>/<tt>false</tt>/anything
			</td>
			<td>
				Any non-<tt>nil|false</tt> value instructs Lanes keeps track of all lanes, so that <a href="#tracking"><tt>lanes.threads()</tt></a> can list them. If <tt>false</tt>, <tt>lanes.threads()</tt> will raise an error when called.
				Default is <tt>false</tt>.
			</td>
		</tr>

		<tr valign=top>
			<td id="on_state_create">
				<code>.on_state_create</code>
			</td>
			<td>
				function/<tt>nil</tt>
			</td>
			<td>
				If provided, will be called in every created Lua state right after initializing the base libraries.
				<br/>
				Keeper states will call it as well, but only if it is a C function (keeper states are not able to execute any user Lua code).
				<br/>
				Typical usage is twofold:
				<ul>
					<li>Tweak <tt>package.loaders</tt></li>
					<li>Load some additional C functions in the global space (of course only a C function will be able to do this).</li>
				</ul>
				That way, all changes in the state can be properly taken into account when building the function lookup database. Default is <tt>nil</tt>.
				<br/>
				(Since version 3.7.6) If <tt>on_state_create()</tt> is a Lua function, it will be transfered normally before the call.
				<br/>
				If it is a C function, a C closure will be reconstructed in the created state from the C pointer. Lanes will raise an error if the function has upvalues.
			</td>
		</tr>

		<tr valign=top>
			<td id="shutdown_timeout">
				<code>.shutdown_timeout</code>
			</td>
			<td>
				number >= 0
			</td>
			<td>
				(Since v3.3.0) Sets the duration in seconds Lanes will wait for graceful termination of running lanes at application shutdown. Irrelevant for builds using pthreads. Default is <tt>0.25</tt>.
			</td>
		</tr>
	</table>
</p>

<p>
	(Since v3.5.0) Once Lanes is configured, one should register with Lanes the modules exporting functions that will be transferred either during lane generation or through <a href="#lindas">lindas</a>.
	<br/>
	Use <tt>lanes.require()</tt> for this purpose. This will call the original <tt>require()</tt>, then add the result to the lookup databases.
	<br/>
	(Since version 3.11) It is also possible to register a given module with <tt>lanes.register()</tt>. This function will raise an error if the registered module is not a function or table.
</p>

<table border="1" bgcolor="#FFFFE0" cellpadding="10" style="width:50%">
	<tr>
		<td>
			<pre>	local m = lanes.require "modname"</pre>
			<pre>	lanes.register( "modname", module)</pre>
		</td>
	</tr>
</table>

<hr/>
<h2 id="creation">Creation</h2>

<p>
	The following sample shows preparing a function for parallel calling, and calling it with varying arguments. Each of the two results is calculated in a separate OS thread, parallel to the calling one. Reading the results joins the threads, waiting for any results not already there.
</p>

<table border=1 bgcolor="#FFFFE0" cellpadding="10" style="width:50%">
	<tr>
		<td>
			<pre>	local lanes = require "lanes".configure()</pre>
			<br/>
			<pre>	f = lanes.gen( function( n) return 2 * n end)</pre>
			<pre>	a = f( 1)</pre>
			<pre>	b = f( 2)</pre>
			<br/>
			<pre>	print( a[1], b[1] )     -- 2    4</pre>
		</td>
	</tr>
</table>
<br/>
<table border=1 bgcolor="#E0E0FF" cellpadding="10" style="width:50%">
	<tr>
		<td>
			<pre>	func = lanes.gen( [libs_str | opt_tbl [, ...],] lane_func)</pre>
			<pre>	lane_h = func( ...)</pre>
		</td>
	</tr>
</table>

<p>
	The function returned by <tt>lanes.gen()</tt> is a "generator" for launching any number of lanes. They will share code, options, initial globals, but the particular arguments may vary. Only calling the generator function actually launches a lane, and provides a handle for controlling it.
	<br/>
	Alternatively, <tt>lane_func</tt> may be a string, in which case it will be compiled in the lane. This was to be able to launch lanes with older versions of LuaJIT, which didn't not support <tt>lua_dump</tt>, used internally to transfer functions to the lane.
</p>

<p>
	Lanes automatically copies upvalues over to the new lanes, so you need not wrap all the required elements into one 'wrapper' function. If <tt>lane_func</tt> uses some local values, or local functions, they will be there also in the new lanes.
</p>

<p>
	<code>libs_str</code> defines the standard libraries made available to the new Lua state:
	<table style="width:100%">
		<tr>
			<td style="width:5%"></td>
			<td>(nothing)</td>
			<td style="width:5%"></td>
			<td>no standard libraries (default)</td>
		</tr>
		<tr>
			<td/>
				<td><tt>"base"</tt> or <tt>""</tt>
			</td>
			<td/>
			<td>
				root level names, <tt>print</tt>, <tt>assert</tt>, <tt>unpack</tt> etc.
			</td>
		</tr>
		<tr>
			<td/>
			<td>
				<tt>"coroutine"</tt>
			</td>
			<td/>
			<td>
				<tt>coroutine.*</tt> namespace (part of base in Lua 5.1 and 5.2)
			</td>
		</tr>
		<tr>
			<td/>
			<td>
				<tt>"debug"</tt>
			</td>
			<td/>
			<td>
				<tt>debug.*</tt> namespace
			</td>
		</tr>
		<tr>
			<td/>
			<td>
				<tt>"io"</tt>
			</td>
			<td/>
			<td>
				<tt>io.*</tt> namespace
			</td>
		</tr>
		<tr>
			<td/>
			<td>
				<tt>"math"</tt>
			</td>
			<td/>
			<td>
				<tt>math.*</tt> namespace
			</td>
		</tr>
		<tr>
			<td/>
			<td>
				<tt>"os"</tt>
			</td>
			<td/>
			<td>
				<tt>os.*</tt> namespace
			</td>
		</tr>
		<tr>
			<td/>
			<td>
				<tt>"package"</tt>
			</td>
			<td/>
			<td>
				<tt>package.*</tt> namespace and <tt>require</tt>
			</td>
		</tr>
		<tr>
			<td/>
			<td>
				<tt>"string"</tt>
			</td>
			<td/>
			<td>
				<tt>string.*</tt> namespace
			</td>
		</tr>
		<tr>
			<td/>
			<td>
				<tt>"table"</tt>
			</td>
			<td/>
			<td>
				<tt>table.*</tt> namespace
			</td>
		</tr>
		<tr>
			<td/>
			<td>
				<tt>"*"</tt>
			</td>
			<td/>
			<td>
				All standard libraries (including those specific to LuaJIT and not listed above), as well as <tt>lanes.core</tt>. This must be used alone.
			</td>
		</tr>
	</table>
</p>

<p>
	Initializing the standard libs takes a bit of time at each lane invocation. This is the main reason why "no libraries" is the default.
</p>

<p>
	<code id="generator_settings">opt_tbl</code> is a collection of named options to control the way lanes are run:
</p>

<p>

	<table border="1" cellpadding="10" style="width:100%">
		<tr>
			<th style="width:15%">name</th>
			<th style="width:15%">value</th>
			<th style="width:70%">definition</th>
		</tr>
		<tr valign=top>
			<td>
				<code>.globals</code>
			</td>
			<td>table</td>
			<td>
				Sets the globals table for the launched threads. This can be used for giving them constants. The key/value pairs of <tt>table</tt> are transfered in the lane globals after the libraries have been loaded and the modules required.
				<br/>
				The global values of different lanes are in no manner connected; modifying one will only affect the particular lane.
			</td>
		</tr>
		<tr id=".required" valign=top>
			<td>
				<code>.required</code>
			</td>
			<td>table</td>
			<td>
				Lists modules that have to be required in order to be able to transfer functions they exposed. Starting with Lanes 3.0-beta, non-Lua functions are no longer copied by recreating a C closure from a C pointer, but are <a href="#function_notes">searched in lookup tables</a>.
				These tables are built from the modules listed here. <tt>required</tt> must be a list of strings, each one being the name of a module to be required. Each module is required with <tt>require()</tt> before the lanes function is invoked.
				So, from the required module's point of view, requiring it manually from inside the lane body or having it required this way doesn't change anything. From the lane body's point of view, the only difference is that a module not creating a global won't be accessible.
				Therefore, a lane body will also have to require a module manually, but this won't do anything more (see Lua's <tt>require</tt> documentation).
				<br/>
				ATTEMPTING TO TRANSFER A FUNCTION REGISTERED BY A MODULE NOT LISTED HERE WILL RAISE AN ERROR.
			</td>
		</tr>
		<tr id="Tr1" valign=top>
			<td>
				<code>.gc_cb</code>
			</td>
			<td>function</td>
			<td>
				(Since version 3.8.2) Callback that gets invoked when the lane is garbage collected. The function receives two arguments (the lane name and a string, either <tt>"closed"</tt> or <tt>"selfdestruct"</tt>).
			</td>
		</tr>
		<tr valign=top>
			<td>
				<code>.priority</code>
			</td>
			<td>integer</td>
			<td>
				The priority of lanes generated in the range -3..+3 (default is 0).
				These values are a mapping over the actual priority range of the underlying implementation.
				<br/>
				Implementation and dependability of priorities varies by platform. Especially Linux kernel 2.6 is not supporting priorities in user mode.
				<br/>
				A lane can also change its own thread priority dynamically with <a href="#priority"><tt>lanes.set_thread_priority()</tt></a>.
			</td>
		</tr>
		<tr valign=top>
			<td>
				<code>.package</code>
			</td>
			<td> table</td>
			<td>
				Introduced at version 3.0.
				<br/>
				Specifying it when <code>libs_str</code> doesn't cause the <code>package</code> library to be loaded will generate an error.
				<br/>
				If not specified, the created lane will receive the current values of <tt>package</tt>. Only <tt>path</tt>, <tt>cpath</tt>, <tt>preload</tt> and <tt>loaders</tt> (Lua 5.1)/<tt>searchers</tt> (Lua 5.2) are transfered.
			</td>
		</tr>
	</table>

<p>
	Each lane also gets a global function <tt>set_debug_threadname()</tt> that it can use anytime to do as the name says. Supported debuggers are Microsoft Visual Studio (for the C side) and Decoda (for the Lua side).
	<br/>
	Starting with version 3.8.1, the lane has a new method <tt>lane:get_debug_threadname()</tt> that gives access to that name from the caller side (returns <tt>"&lt;unnamed&gt;"</tt> if unset, <tt>"&lt;closed&gt;"</tt> if the internal Lua state is closed).
</p>

<p>
	If a lane body pulls a C function imported by a module required before Lanes itself (thus not through a hooked <tt>require</tt>), the lane generator creation will raise an error.
	The function name it shows is a path where it was found by scanning <tt>_G</tt>. As a utility, the name guessing functionality is exposed as such:

	<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%">
		<tr>
			<td>
				<pre>	"type", "name" = lanes.nameof( o)</pre>
			</td>
		</tr>
	</table>
</p>

<p>
	Starting with version 3.8.3, <tt>lanes.nameof()</tt> searches the registry as well.
</p>

<h3>Free running lanes</h3>

<p>
	The lane handles are allowed to be 'let loose'; in other words you may execute a lane simply by:

	<table border="1" bgcolor="#FFFFE0" cellpadding="10" style="width:50%">
		<tr>
			<td>
				<pre>	lanes.gen( function( params) ... end ) ( ...)</pre>
			</td>
		</tr>
	</table>

	Normally, this kind of lanes will be in an eternal loop handling messages. Since the lane handle is gone, there is no way to control such a lane from the outside, nor read its potential return values. Then again, such a lane does not even normally return.
</p>


<!-- priority +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>
<h2 id="priority">Priority</h2>

	<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%">
		<tr>
			<td>
				<pre>	lanes.set_thread_priority( prio)</pre>
			</td>
		</tr>
	</table>
<p>
	Besides setting a default priority in the generator <a href="#generator_settings">settings</a>, each thread can change its own priority at will. This is also true for the main Lua state.
	<br/>
	The priority must be in the range <tt>[-3,+3]</tt>.
</p>


<!-- affinity +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>
<h2 id="affinity">Affinity</h2>

	<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%">
		<tr>
			<td>
				<pre>	lanes.set_thread_affinity( affinity)</pre>
			</td>
		</tr>
	</table>
<p>
	Each thread can change its own affinity at will. This is also true for the main Lua state.
</p>


<!-- status +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>
<h2 id="status">Status</h2>

	<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%">
		<tr>
			<td>
				<pre>	str = lane_h.status</pre>
			</td>
		</tr>
	</table>

<p>
	The current execution state of a lane can be read via its <tt>status</tt> member, providing one of these values: <sup>(<a href="#2">2</a>)</sup>

	<table style="width:100%">
		<tr>
			<td style="width:5%"></td>
			<td>
				<tt>"pending"</tt>
			</td>
			<td style="width:5%"></td>
			<td>
				Not started yet. Shouldn't stay very long in that state.
			</td>
		</tr>
		<tr>
			<td/>
			<td>
				<tt>
					"running"
				</tt>
			</td>
			<td/>
			<td>
				running, not suspended on a <a href="#lindas">Linda</a> call.
			</td>
		</tr>
		<tr>
			<td/>
			<td>
				<tt>"waiting"</tt>
			</td>
			<td/>
			<td>
				waiting at a <a href="#lindas">Linda</a> <tt>:receive()</tt> or <tt>:send()</tt>
			</td>
		</tr>
		<tr>
			<td/>
			<td>
				<tt>"done"</tt>
			</td>
			<td/>
			<td>
				finished executing (results are ready)
			</td>
		</tr>
		<tr>
			<td/>
			<td>
				<tt>"error"</tt>
			</td>
			<td/>
			<td>
				met an error (reading results will propagate it)
			</td>
		</tr>
		<tr>
			<td/>
			<td>
				<tt>"cancelled"</tt>
			</td>
			<td/>
			<td>
				received <a href="#cancelling">cancellation</a> and finished itself.
			</td>
		</tr>
		<tr>
			<td/>
			<td>
				<tt>"killed"</tt>
			</td>
			<td/>
			<td>
				was forcefully killed by <tt>lane_h:cancel()</tt> (since v3.3.0)
			</td>
	</tr>
	</table>
</p>

<p>
	This is similar to <tt>coroutine.status</tt>, which has: <tt>"running"</tt> / <tt>"suspended"</tt> / <tt>"normal"</tt> / <tt>"dead"</tt>. Not using the exact same names is intentional.
</p>


<!-- tracking +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>
<h2 id="tracking">Tracking</h2>

	<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%">
		<tr>
			<td>
				<pre>	{{name = "name", status = "status", ...}|nil = lanes.threads()</pre>
			</td>
		</tr>
	</table>

<p>
	Only available if lane tracking feature is compiled (see <tt>HAVE_LANE_TRACKING</tt> in <tt>lanes.c</tt>) and <a href="#track_lanes"><tt>track_lanes</tt></a> is set.
	<br/>
	Returns an array table where each entry is a table containing a lane's name and status. Returns <tt>nil</tt> if no lane is running.
</p>


<!-- results +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>
<h2 id="results">Results and errors</h2>

<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%"><tr><td><pre>
	set_error_reporting( "basic"|"extended")
</pre></td></tr></table>

<p>
	Sets the error reporting mode. "basic" is selected by default.
</p>

<p>
	A lane can be waited upon by simply reading its results. This can be done in two ways.
</p>

<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%"><tr><td><pre>
	[val]= lane_h[1]
</pre></td></tr></table>

<p>
	Makes sure lane has finished, and gives its first (maybe only) return value. Other return values will be available in other <tt>lane_h</tt> indices.
	<br/>
	If the lane ended in an error, it is propagated to master state at this place.
</p>

<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%"><tr><td><pre>
	[...]|[nil,err,stack_tbl]= lane_h:join( [timeout_secs] )
</pre></td></tr></table>

<p>
	Waits until the lane finishes, or <tt>timeout</tt> seconds have passed. Returns <tt>nil, "timeout"</tt> on timeout (since v3.13), <tt>nil,err,stack_tbl</tt> if the lane hit an error, <tt>nil, "killed"</tt> if forcefully killed (starting with v3.3.0), or the return values of the lane.
	Unlike in reading the results in table fashion, errors are not propagated.
</p>

<p>
<tt>stack_tbl</tt> is a table describing where the error was thrown.
	<br/>
  In <tt>"extended"</tt> mode, <tt>stack_tbl</tt> is an array of tables containing info gathered with <tt>lua_getinfo()</tt> (<tt>"source"</tt>,<tt>"currentline"</tt>,<tt>"name"</tt>,<tt>"namewhat"</tt>,<tt>"what"</tt>).
	<br/>
	In <tt>"basic mode"</tt>, <tt>stack_tbl</tt> is an array of "&lt;filename&gt;:&lt;line&gt;" strings. Use <tt>table.concat()</tt> to format it to your liking (or just ignore it).
</p>

<p>
	If you use <tt>:join</tt>, make sure your lane main function returns a non-nil value so you can tell timeout and error cases apart from succesful return (using the <tt>.status</tt> property may be risky, since it might change between a timed out join and the moment you read it).
</p>

<p>

<table border=1 bgcolor="#FFFFE0" cellpadding="10" style="width:50%"><tr><td><pre>
	require "lanes".configure()

	f = lanes.gen( function() error "!!!" end)
	a = f( 1)

	--print( a[1])   -- propagates error

	v, err = a:join()   -- no propagation
	if v == nil then
		error( "'a' faced error"..tostring(err))   -- manual propagation
	end
</pre></td></tr></table>

<p>
	If you want to wait for multiple lanes to finish (any of a set of lanes), use a <a href="#lindas">Linda</a> object. Give each lane a specific id, and send that id over a <a href="#lindas">Linda</a> once that thread is done (as the last thing you do).
</p>

<table border=1 bgcolor="#FFFFE0" cellpadding="10" style="width:50%"><tr><td><pre>
	require "lanes".configure()

	local sync_linda = lanes.linda()
	f = lanes.gen( function() dostuff() sync_linda:send( "done", true) end)
	a = f()
	b = f()
	c = f()

	sync_linda:receive( nil, sync_linda.batched, "done", 3) -- wait for 3 lanes to write something in "done" slot of sync_linda
</pre></td></tr></table>

<!-- cancelling +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>
<h2 id="cancelling">Cancelling</h2>

<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%"><tr><td><pre>
	bool[,reason] = lane_h:cancel( "soft" [, timeout] [, wake_bool])
	bool[,reason] = lane_h:cancel( "hard" [, timeout] [, force [, forcekill_timeout]])
	bool[,reason] = lane_h:cancel( [mode, hookcount] [, timeout] [, force [, forcekill_timeout]])
</pre></td></tr></table>

<p>
	<tt>cancel()</tt> sends a cancellation request to the lane.<br/>
	First argument is a <tt>mode</tt> can be one of <tt>"hard"</tt>, <tt>"soft"</tt>, <tt>"count"</tt>, <tt>"line"</tt>, <tt>"call"</tt>, <tt>"ret"</tt>.
	If <tt>mode</tt> is not specified, it defaults to <tt>"hard"</tt>.
</p>
<p>
	If <tt>mode</tt> is <tt>"soft"</tt>, cancellation will only cause <tt>cancel_test()</tt> to return <tt>true</tt>, so that the lane can cleanup manually.<br/>
	If <tt>wake_bool</tt> is <tt>true</tt>, the lane is also signalled so that execution returns from any pending linda operation. Linda operations detecting the cancellation request return <tt>lanes.cancel_error</tt>.
</p>
<p>
	If <tt>mode</tt> is <tt>"hard"</tt>, waits for the request to be processed, or a timeout to occur. Linda operations detecting the cancellation request will raise a special cancellation error (meaning they won't return in that case).<br/>
	<tt>timeout</tt> defaults to 0 if not specified.
</p>
<p>
	Other values of <tt>mode</tt> will asynchronously install the corresponding hook, then behave as <tt>"hard"</tt>.
</p>
<p>
	If <tt>force_kill_bool</tt> is <tt>true</tt>, <tt>forcekill_timeout</tt> can be set to tell how long lanes will wait for the OS thread to terminate before raising an error. Windows threads always terminate immediately, but it might not always be the case with some pthread implementations.
</p>
<p>
	Returns <tt>true, lane_h.status</tt> if lane was already done (in <tt>"done"</tt>, <tt>"error"</tt> or <tt>"cancelled"</tt> status), or the cancellation was fruitful within <tt>timeout_secs</tt> timeout period.<br/>
	Returns <tt>false, "timeout"</tt> otherwise.
</p>
<p>
	If the lane is still running after the timeout expired and <tt>force_kill</tt> is <tt>true</tt>, the OS thread running the lane is forcefully killed. This means no GC, probable OS resource leaks (thread stack, locks, DLL notifications), and should generally be the last resort.
</p>
<p>
	Cancellation is tested <u>before</u> going to sleep in <tt>receive()</tt> or <tt>send()</tt> calls and after executing <tt>cancelstep</tt> Lua statements. Starting with version 3.0-beta, a pending <tt>receive()</tt>or <tt>send()</tt> call is awakened.
	<br/>
	This means the execution of the lane will resume although the operation has not completed, to give the lane a chance to detect cancellation (even in the case the code waits on a <a href="#lindas">linda</a> with infinite timeout).
	<br/>
	The code should be able to handle this situation appropriately if required (in other words, it should gracefully handle the fact that it didn't receive the expected values).
	<br/>
	It is also possible to manually test for cancel requests with <tt>cancel_test()</tt>.
</p>


<!-- finalizers +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>
<h2 id="finalizers">Finalizers</h2>

<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%"><tr><td><pre>
	set_finalizer( finalizer_func)

	void = finalizer_func( [err, stack_tbl])
</pre></td></tr></table>

<p>
	The <tt>error</tt> call is used for throwing exceptions in Lua. What Lua does not offer, however, is scoped <a href="http://en.wikipedia.org/wiki/Finalizer">finalizers</a>
	that would get called when a certain block of instructions gets exited, whether through peaceful return or abrupt <tt>error</tt>.
</p>

<p>
	Since 2.0.3, Lanes registers a function <tt>set_finalizer</tt> in the lane's Lua state for doing this.
	Any functions given to it will be called in the lane Lua state, just prior to closing it. It is possible to set more than one finalizer. They are not called in any particular order.
</p>

<p>
	An error in a finalizer itself overrides the state of the regular chunk (in practise, it would be highly preferable <i>not</i> to have errors in finalizers). If one finalizer errors, the others may not get called.
	If a finalizer error occurs after an error in the lane body, then this new error replaces the previous one (including the full stack trace).
</p>

<table border="1" bgcolor="#FFFFE0" cellpadding="10" style="width:50%"><tr><td><pre>
	local lane_body = function()
		set_finalizer( function( err, stk)
			if err and type( err) ~= "userdata" then
				-- no special error: true error
				print( " error: "..tostring(err))
			elseif type( err) == "userdata" then
				-- lane <a href="#cancelling">cancellation</a> is performed by throwing a special userdata as error
				print( "after cancel")
			else
				-- no error: we just got finalized
				print( "finalized")
			end
		end)
	end
</pre></td></tr></table>


<!-- lindas +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>
<h2 id="lindas">Lindas</h2>

<p>
	Communications between lanes is completely detached from the lane handles themselves. By itself, a lane can only provide return values once it's finished, or throw an error.
	Needs to communicate during runtime are handled by <a href="http://en.wikipedia.org/wiki/Linda_%28coordination_language%29" target="_blank">Linda objects</a>, which are
	<a href="#deep_userdata">deep userdata</a> instances. They can be provided to a lane as startup parameters, upvalues or in some other Linda's message.
</p>

<p>
	Access to a Linda object means a lane can read or write to any of its data slots. Multiple lanes can be accessing the same Linda in parallel. No application level locking is required; each Linda operation is atomic.
</p>

<table border="1" bgcolor="#FFFFE0" cellpadding="10" style="width:50%"><tr><td><pre>
	require "lanes".configure()

	local linda = lanes.linda()

	local function loop( max)
		for i = 1, max do
			print( "sending: " .. i)
			linda:send( "x", i)    -- linda as upvalue
		end
	end

	a = lanes.gen( "", loop)( 10000)

	while true do
		local key, val = linda:receive( 3.0, "x")    -- timeout in seconds
		if val == nil then
			print( "timed out")
			break
		end
		print( tostring( linda) .. " received: " .. val)
	end
</pre></td></tr></table>

<p>
	Characteristics of the Lanes implementation of Lindas are:

	<ul>
		<li>Keys can be of boolean, number, string or light userdata type. Tables and functions can't be keys because their identity isn't preserved when transfered from one Lua state to another.</li>
		<li>values can be any type supported by inter-state copying (same <a href="#limitations">limits</a> as for function parameters and upvalues).</li>
		<li>consuming method is <tt>:receive</tt> (not in).</li>
		<li>non-consuming method is <tt>:get</tt> (not rd).</li>
		<li>two producer-side methods: <tt>:send</tt> and <tt>:set</tt> (not out).</li>
		<li><tt>send</tt> allows for sending multiple values -atomically- to a given key.</li>
		<li><tt>receive</tt> can wait for multiple keys at once.</li>
		<li><tt>receive</tt> has a batched mode to consume more than one value from a single key, as in <tt>linda:receive( 1.0, linda.batched, "key", 3, 6).</tt></li>
		<li>individual keys' queue length can be limited, balancing speed differences in a producer/consumer scenario (making <tt>:send</tt> wait).</li>
		<li><tt>tostring( linda)</tt> returns a string of the form <tt>"Linda: &lt;opt_name&gt;"</tt></li>
		<li>several lindas may share the same keeper state. Since version 3.9.1, state assignation can be controlled with the linda's group (an integer). All lindas belonging to the same group will share the same keeper state. One keeper state may be shared by several groups.</li>
	</ul>
</p>

<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%"><tr><td><pre>
	h = lanes.linda( [opt_name, [opt_group]])

	[true|lanes.cancel_error] = h:send( [timeout_secs,] [h.null,] key, ...)

	[key, val]|[lanes.cancel_error] = h:receive( [timeout_secs,] key [, ...])

	[key, val [, ...]]|[lanes.cancel_error] = h:receive( timeout, h.batched, key, n_uint_min[, n_uint_max])

	[true|lanes.cancel_error] = h:limit( key, n_uint)
</pre></td></tr></table>

<p>
	The <tt>send()</tt> and <tt>receive()</tt> methods use Linda keys as FIFO stacks (first in, first out). Timeouts are given in seconds (millisecond accuracy). If using numbers as the first Linda key, one must explicitly give <tt>nil</tt> as the timeout parameter to avoid ambiguities.
</p>

<p>
	By default, stack sizes are unlimited but limits can be enforced using the <tt>limit()</tt> method. This can be useful to balance execution speeds in a producer/consumer scenario. Any negative value removes the limit.
	<br/>
	A limit of 0 is allowed to block everything.
	<br/>
	(Since version 3.7.7) if the key was full but the limit change added some room, <tt>limit()</tt> returns <tt>true</tt> and the linda is signalled so that <tt>send()</tt>-blocked threads are awakened.
</p>

<p>
	Note that any number of lanes can be reading or writing a Linda. There can be many producers, and many consumers. It's up to you.
</p>

<p>
	<a href="#cancelling">Hard cancellation</a> will cause pending linda operations to abort execution of the lane through a cancellation error. This means that you have to install a <a href="#finalizers">finalizer</a> in your lane if you want to run some code in that situation.
</p>

<p>
	<tt>send()</tt> returns <tt>true</tt> if the sending succeeded, and <tt>false</tt> if the queue limit was met, and the queue did not empty enough during the given timeout.
	<br/>
	(Since version 3.7.8) <tt>send()</tt> returns <tt>lanes.cancel_error</tt> if interrupted by a soft cancel request.
	<br/>
	If no data is provided after the key, <tt>send()</tt> raises an error. Since version 3.9.3,  if provided with <tt>linda.null</tt> before the actual key and there is no data to send, <tt>send()</tt> sends a single <tt>nil</tt>.
	<br/>
	Also, if <tt>linda.null</tt> is sent as data in a linda, it will be read as a <tt>nil</tt>.
</p>

<p>
	Equally, <tt>receive()</tt> returns a key and the value extracted from it, or nothing for timeout. Note that <tt>nil</tt>s can be sent and received; the <tt>key</tt> value will tell it apart from a timeout.
	<br/>
	Version 3.4.0 introduces an API change in the returned values: <tt>receive()</tt> returns the key followed by the value(s), in that order, and not the other way around.
	<br/>
	(Since version 3.7.8) <tt>receive()</tt> returns <tt>lanes.cancel_error</tt> if interrupted by a soft cancel request.
</p>

<p>
	Multiple values can be sent to a given key at once, atomically (the send will fail unless all the values fit within the queue limit). This can be useful for multiple producer scenarios, if the protocols used are giving data in streams of multiple units.
	Atomicity avoids the producers from garbling each others messages, which could happen if the units were sent individually.
</p>

<p>
	When receiving from multiple slots, the keys are checked in order, which can	be used for making priority queues.
</p>

<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%"><tr><td><pre>
	bool|lanes.cancel_error = linda_h:set( key [, val [, ...]])

	[[val [, ...]]|lanes.cancel_error] = linda_h:get( key [, count = 1])
</pre></td></tr></table>

<p>
	The table access methods are for accessing a slot without queuing or consuming. They can be used for making shared tables of storage among the lanes.
	<br/>
	Writing to a slot never blocks because it ignores the limit. It overwrites existing value and clears any possible queued entries.
	<br/>
	Reading doesn't block either because <tt>get()</tt> returns whatever is available (which can be nothing), up to the specified count.
	<br/>
	Table access and <tt>send()</tt>/<tt>receive()</tt> can be used together; reading a slot essentially peeks the next outcoming value of a queue.
</p>

<p>
	<tt>set()</tt> signals the linda for write if a value is stored. If nothing special happens, <tt>set() </tt>returns nothing.
	<br/>
	Since version 3.7.7, if the key was full but the new data count of the key after <tt>set()</tt> is below its limit, <tt>set()</tt> returns <tt>true</tt> and the linda is also signaled for read so that <tt>send()</tt>-blocked threads are awakened.
</p>

<p>
	Since version 3.8.0, <tt>set()</tt> can write several values at the specified key, writing <tt>nil</tt> values is now possible, and clearing the contents at the specified key is done by not providing any value.
	<br/>
	Also, <tt>get()</tt> can read several values at once. If the key contains no data, <tt>get()</tt> returns no value. This can be used to separate the case when reading stored <tt>nil</tt> values.
</p>

<p>
	Since version 3.8.4, trying to send or receive data through a cancelled linda does nothing and returns <tt>lanes.cancel_error</tt>.
</p>

<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%"><tr><td><pre>
	[val] = linda_h:count( [key[,...]])
</pre></td></tr></table>

<p>
	Returns some information about the contents of the linda.
	<br/>
	If no key is specified, and the linda is empty, returns nothing.
	<br/>
	If no key is specified, and the linda is not empty, returns a table of key/count pairs that counts the number of items in each of the exiting keys of the linda. This count can be 0 if the key has been used but is empty.
	<br/>
	If a single key is specified, returns the number of pending items, or nothing if the key is unknown.
	<br/>
	If more than one key is specified, return a table of key/count pairs for the known keys.
</p>

<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%"><tr><td><pre>
	[table] = linda_h:dump()
</pre></td></tr></table>

<p>
	Returns a table describing the full contents of a linda, or <tt>nil</tt> if the linda wasn't used yet.
</p>

<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%"><tr><td><pre>
	void = linda_h:cancel("read"|"write"|"both"|"none")
</pre></td></tr></table>

<p>
	(Starting with version 3.8.4) Signals the linda so that lanes waiting for read, write, or both, wake up.
	All linda operations (including <tt>get()</tt> and <tt>set()</tt>) will return <tt>lanes.cancel_error</tt> as when the calling lane is <a href="#cancelling">soft-cancelled</a> as long as the linda is marked as cancelled.
	<br/>
	<tt>"none"</tt> reset the linda's cancel status, but doesn't signal it.
	<br/>
	If not void, the lane's cancel status overrides the linda's cancel status.
</p>

<h3>Granularity of using Lindas</h3>

<p>
	A linda is a gateway to read and write data inside some hidden Lua states, called keeper states. Lindas are hashed to a fixed number of keeper states, which are a locking entity.
	<br/>
	The data sent through a linda is stored inside the associated keeper state in a Lua table where each linda slot is the key to another table containing a FIFO for that slot.
	<br/>
	Each keeper state is associated with an OS mutex, to prevent concurrent access to the keeper state. The linda itself uses two signals to be made aware of operations occuring on it.
	<br/>
	Whenever Lua code reads from or writes to a linda, the mutex is acquired. If linda limits don't block the operation, it is fulfilled, then the mutex is released.
	<br/>
	If the linda has to block, the mutex is released and the OS thread sleeps, waiting for a linda operation to be signalled. When an operation occurs on the same linda, possibly fufilling the condition, or a timeout expires, the thread wakes up.
	<br/>
	If the thread is woken but the condition is not yet fulfilled, it goes back to sleep, until the timeout expires.
	<br/>
	When a lane is cancelled, the signal it is waiting on (if any) is signalled. In that case, the linda operation will return <tt>lanes.cancel_error</tt>.
</p>

<p>
	A single Linda object provides an infinite number of slots, so why would you want to use several?
</p>

<p>
	There are some important reasons:
	<ul>
		<li>
			Access control. If you don't trust certain code completely, or just to modularize your design, use one Linda for one usage and another one
			for the other. This keeps your code clear and readable. You can pass multiple Linda handles to a lane with practically no added cost.
		</li>

		<li>
			Namespace control. Linda keys have a "flat" namespace, so collisions are possible if you try to use the same Linda for too many separate uses.
		</li>

		<li>
			Performance. Changing any slot in a Linda causes all pending threads for that Linda to be momentarily awakened (at least in the C level).
			This can degrade performance due to unnecessary OS level context switches. The more keeper states you declared with <tt>lanes.configure()</tt> the less this should be a problem.
		</li>
	</ul>

On the other side, you need to use a common Linda for waiting for multiple keys. You cannot wait for keys from two separate Linda objects at the same time.
</p>

<p>
<font size="-1">Actually, you can. Make separate lanes to wait each, and then multiplex those
events to a common Linda, but... :).</font>
</p>


<!-- timers +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>
<h2 id="timers">Timers</h2>

<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%"><tr><td><pre>
	void = lanes.timer( linda_h, key, date_tbl|first_secs [,period_secs])
</pre></td></tr></table>

<p>
	Timers are implemented as a lane. They can be disabled by setting "<tt><a href="#with_timers">with_timers</a></tt>" to <tt>nil</tt> or <tt>false</tt> to <tt>lanes.configure()</tt>.
</p>

<p>
	Timers can be run once, or in a reoccurring fashion (<tt>period_secs > 0</tt>). The first occurrence can be given either as a date or as a relative delay in seconds. The <tt>date</tt> table is like what <tt>os.date("*t")</tt> returns, in the local time zone.
</p>

<p>
	Once a timer expires, the <tt>key</tt> is set with the current time (in seconds, same offset as <tt>os.time()</tt> but with millisecond accuracy). The key can be waited upon using the regular Linda <tt>:receive()</tt> method.
</p>

<p>
	A timer can be stopped simply with <tt>first_secs=0|nil</tt> and no period.
</p>

<table border="1" bgcolor="#FFFFE0" cellpadding="10" style="width:50%"><tr><td><pre>
	local lanes = require "lanes"
	lanes.configure()

	local linda = lanes.linda()

	-- First timer once a second, not synchronized to wall clock
	--
	lanes.timer( linda, "sec", 1, 1)

	-- Timer to a future event (next even minute); wall clock synchronized
	--
	local t = os.date( "*t", os.time() + 60)    -- now + 1min
	t.sec = 0

	lanes.timer( linda, "min", t, 60)   -- reoccur every minute (sharp)

	while true do
		local key, v = linda:receive( "sec", "min")
		print( "Timer "..key..": "..v)
	end
</pre></td></tr></table>

<p>
	NOTE: Timer keys are set, not queued, so missing a beat is possible especially if the timer cycle is extremely small. The key value can be used to know the actual time passed.
</p>

<table>
	<tr>
		<td valign=top><i><nobr>Design note:</nobr></i></td>
		<td>
			<font size="-1">
			Having the API as <tt>lanes.timer()</tt> is intentional. Another alternative would be <tt>linda_h:timer()</tt> but timers are not traditionally seen to be part of Lindas. Also, it would mean any lane getting a Linda handle would be able to modify timers on it.
			A third choice could be abstracting the timers out of Linda realm altogether (<tt>timer_h= lanes.timer( date|first_secs, period_secs )</tt>) but that would mean separate waiting functions for timers, and lindas.
			Even if a linda object and key was returned, that key couldn't be waited upon simultaneously with one's general linda events.
			The current system gives maximum capabilities with minimum API, and any smoothenings can easily be crafted in Lua at the application level.
			</font>
		</td>
	</tr>
</table>

<p></p>

<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%"><tr><td><pre>
	{[{linda, slot, when, period}[,...]]} = lanes.timers()
</pre></td></tr></table>

<p>
	The full list of active timers can be obtained. Obviously, this is a snapshot, and non-repeating timers might no longer exist by the time the results are inspected.
</p>

<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%"><tr><td><pre>
	void = lanes.sleep( [seconds|false])
</pre></td></tr></table>

<p>
	(Since version 3.9.7) A very simple way of sleeping when nothing else is available. Is implemented by attempting to read some data in an unused channel of the internal linda used for timers (this linda exists even when timers aren't enabled).
	Default duration is null, which should only cause a thread context switch.
</p>

<!-- locks +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>
<h2 id="locks">Locks etc.</h2>

<p>
	Lanes does not generally require locks or critical sections to be used, at all. If necessary, a limited queue can be used to emulate them. <tt>lanes.lua</tt>	offers some sugar to make it easy:
</p>

<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%"><tr><td><pre>
	lock_func|lanes.cancel_error = lanes.genlock( linda_h, key [,N_uint=1])

	bool|lanes.cancel_error = lock_func( M_uint [, "try"] )     -- acquire
	..
	bool|lanes.cancel_error = lock_func( -M_uint)    -- release
</pre></td></tr></table>

<p>
	The generated function acquires M tokens from the N available, or releases them if the value is negative. The acquiring call will suspend the lane, if necessary. Use <tt>M=N=1</tt> for a critical section lock (only one lane allowed to enter).
	<br/>
	When passsing <tt>"try"</tt> as second argument when acquiring, then <tt>lock_func</tt> operates on the linda with a timeout of 0 to emulate a TryLock() operation. If locking fails, <tt>lock_func</tt> returns <tt>false</tt>. <tt>"try"</tt> is ignored when releasing (as it it not expected to ever have to wait unless the acquisition/release pairs are not properly matched).
	<br/>
	Upon successful lock/unlock, <tt>lock_func</tt> returns <tt>true</tt> (always the case when block-waiting for completion).
</p>

<p>
	Note: The generated locks are <u>not recursive</u> (A single lane locking several times will consume tokens at each call, and can therefore deadlock itself). That would need another kind of generator, which is currently not implemented.
</p>

<p>
	Similar sugar exists for atomic counters:
</p>

<p>

<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%"><tr><td><pre>
	atomic_func|lanes.cancel_error = lanes.genatomic( linda_h, key [,initial_num=0.0])

	new_num|lanes.cancel_error = atomic_func( [diff_num=+1.0])
</pre></td></tr></table>

<p>
	Each time called, the generated function will change <tt>linda[key]</tt> atomically, without other lanes being able to interfere. The new value is returned. You can use either <tt>diff 0.0</tt> or <tt>get</tt> to just read the current value.
</p>

<p>
	Note that the generated functions can be passed on to other lanes.
</p>


<!-- others +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>
<h2 id="other">Other issues</h2>

<h3>Limitations on data passing</h3>

<p>
	Data passed between lanes (either as starting parameters, return values, upvalues or via Lindas) must conform to the following:
</p>

<p>
	<ul>
		<li>Booleans, numbers, strings, light userdata, Lua functions and tables of such can always be passed.</li>
			<ul>
				<li>Versions 3.4.1 and earlier had an undocumented limitation: Lua functions with an indirect recursive Lua function upvalue raised an error when transfered. This limitation disappeared with version 3.4.2.</li>
			</ul>
		<li>
			Cyclic tables and/or duplicate references are allowed and reproduced appropriately, but only <u>within the same transmission</u>.
			<ul>
				<li>Using the same source table in multiple Linda messages keeps no ties between the tables (this is the same reason why tables can't be used as keys).</li>
			</ul>
		</li>
		<li>
			Objects (tables with a metatable) are copyable between lanes.
			<ul>
				<li>Metatables are assumed to be immutable; they are internally indexed and only copied once per each type of objects per lane.</li>
			</ul>
		</li>
		<li>
			C functions (<tt>lua_CFunction</tt>) referring to <tt>LUA_ENVIRONINDEX</tt> or <tt>LUA_REGISTRYINDEX</tt> might not do what you expect in the target, since they will actually use a different environment.
		</li>
		<li>
			Lua 5.2 functions may have a special <tt>_ENV</tt> upvalue if they perform 'global namespace' lookups. Unless special care is taken, this upvalue defaults to the table found at <tt>LUA_RIDX_GLOBALS</tt>.
			Obviously, we don't want to transfer the whole global table along with each Lua function. Therefore, any upvalue equal to the global table is not transfered by value, but simply bound
			to the global table in the destination state. Note that this also applies when Lanes is built for Lua 5.1, as it doesn't hurt.
		</li>
		<li>
			Full userdata can be passed only if it's prepared using the <a href="#deep_userdata">deep userdata</a> system, which handles its lifespan management
			<ul>
				<li>In particular, lane handles cannot be passed between lanes.</li>
				<li>Lanes can either throw an error or attempt a <a href="#demote_full_userdata">light userdata demotion</a>.</li>
			</ul>
		</li>
		<li>Coroutines cannot be passed. A coroutine's Lua state is tied to the Lua state that created it, and there is no way the mixed C/Lua stack of a coroutine can be transfered from one Lua state to another.</li>
		<li>Starting with version 3.10.1, if the metatable contains <tt>__lanesignore</tt>, the object is skipped and <tt>nil</tt> is transfered instead.</li>
	</ul>
</p>


<h3 id="function_notes">Notes about passing C functions</h3>

<p>
	Originally, a C function was copied from one Lua state to another as follows:
</p>

<table border="1" bgcolor="#FFFFE0" cellpadding="10" style="width:50%"><tr><td><pre>
	// expects a C function on top of the source Lua stack
	copy_func( lua_State *dest, lua_State* source)
	{
		// extract C function pointer from source
		lua_CFunction func = lua_tocfunction( source, -1);
		// transfer upvalues
		int nup = transfer_upvalues( dest, source);
		// dest Lua stack contains a copy of all upvalues
		lua_pushcfunction( dest, func, nup);
	}
</pre></td></tr></table>

<p>
	This has the main drawback of not being LuaJIT-compatible, because some functions registered by LuaJIT are not regular C functions, but specially optimized implementations. As a result, <tt>lua_tocfunction()</tt> returns <tt>NULL</tt> for them.
	<br/>
	Therefore, Lanes no longer transfers functions that way. Instead, functions are transfered as follows (more or less):
</p>

<table border="1" bgcolor="#FFFFE0" cellpadding="10" style="width:50%"><tr><td><pre>
	// expects a C function on top of the source Lua stack
	copy_func( lua_State *dest, lua_State* source)
	{
		// fetch function 'name' from source lookup database
		char const* funcname = lookup_func_name( source, -1);
		// lookup a function bound to this name in the destination state, and push it on the stack
		push_resolved_func( dest, funcname);
	}
</pre></td></tr></table>

<p>
	The devil lies in the details: what does "function lookup" mean?
</p>

<p>
	Since functions are first class values, they don't have a name. All we know for sure is that when a C module registers some functions, they are accessible to the script that required the module through some exposed variables.
	<br/>
	For example, loading the <tt>string</tt> base library creates a table accessible when indexing the global environment with key <tt>"string"</tt>. Indexing this table with <tt>"match"</tt>, <tt>"gsub"</tt>, etc. will give us a function.
	<br/>
	When a lane generator creates a lane and performs initializations described by the list of base libraries and the list of required modules, it recursively scans the table created by the initialisation of the module, looking for all values that are C functions.
	<br/>
	Each time a function is encountered, the sequence of keys that reached that function is contatenated in a (hopefully) unique name. The [name, function] and [function, name] pairs are both stored in a lookup table in all involved Lua states (main Lua state and lanes states).
	<br/>
	Then when a function is transfered from one state to another, all we have to do is retrieve the name associated to a function in the source Lua state, then with that name retrieve the equivalent function that already exists in the destination state.
	<br/>
	Note that there is no need to transfer upvalues, as they are already bound to the function registered in the destination state. (And in any event, it is not possible to create a closure from a C function pushed on the stack, it can only be created with a <tt>lua_CFunction</tt> pointer).
</p>

<p>
	There are several issues here:
	<ul>
		<li>Some base libraries register some C functions in the global environment. Because of that, Lanes must scan the global namespace to find all C functions (such as <tt>error</tt>, <tt>print</tt>, etc.).</li>
		<li>
			Nothing prevents a script to create other references to a C function. For example one could do
			<table border="1" bgcolor="#FFFFE0" cellpadding="10" style="width:50%"><tr><td><pre>
				string2 = string
			</pre></td></tr></table>
			When iterating over all keys of the global table, Lanes has no guarantee that it will hit <tt>"string"</tt> before or after <tt>"string2"</tt>. However, the values associated to <tt>string.match</tt> and <tt>string2.match</tt> are the same C function.
			Lanes doesn't normally expect a C function value to be encountered more than once. In the event it occurs, the shortest name that was computed is retained.
			If Lanes processed <tt>"string2"</tt> first, it means that if the Lua state that contains the <tt>"string2"</tt> global name sends function <tt>string.match</tt>, <tt>lookup_func_name</tt> would return name <tt>"string2.match"</tt>, with the obvious effect that <tt>push_resolved_func</tt>
			won't find <tt>"string2.match"</tt> in the destination lookup database, thus failing the transfer (even though this function exists, but is referenced under name <tt>"string.match"</tt>).
		</li>
		<li>
			Lua 5.2 introduced a hash randomizer seed which causes table iteration to yield a different key order on different VMs even when the tables are populated the exact same way.
			When Lua is built with compatibility options (such as LUA_COMPAT_ALL), this causes several base libraries to register functions under multiple names.
			This, with the randomizer, can cause the first encountered name of a function to be different on different VMs, which breaks function transfer.
			Even under Lua 5.1, this may cause trouble if some module registers a function under several keys.
			To circumvent this, Lanes has to select one name among all candidates, and the rule for this is to keep the 'smaller' one: first in byte count, then in lexical order.
		</li>
	</ul>
	Another more immediate reason of failed transfer is when the destination state doesn't know about the C function that has to be transferred. This occurs if a function is transferred in a lane before it had a chance to scan the module.
	If the C function is sent through a linda, it is enough for the destination lane body to have required the module before the function is sent.
	But if the lane body provided to the generator has a C function as upvalue, the transfer itself must succeed, therefore the module that imported that C function must be required in the destination lane before the lane body starts executing. This is where the <a href = "#.required"><tt>.required</tt></a> options play their role.
</p>


<h3>Required of module makers</h3>

<p>
	Most Lua extension modules should work unaltered with Lanes. If the module simply ties C side features to Lua, everything is fine without alterations. The <tt>luaopen_...()</tt> entry point will be called separately for each lane, where the module is <tt>require</tt>'d from.
</p>

<p>
	If it, however, also does one-time C side initializations, these should be covered into a one-time-only construct such as below.
</p>

<table border="1" bgcolor="#FFFFE0" cellpadding="10" style="width:50%"><tr><td><pre>
	int luaopen_module( lua_State *L )
	{
		static char been_here;  /* 0 by ANSI C */

		// Calls to 'require' serialized by Lanes; this is safe.
		if (!been_here)
		{
			been_here= 1;
			... one time initializations ...
		}
		... binding to Lua ...
	}
</pre></td></tr></table>

<h3 id="clonable_userdata">Clonable full userdata in your own apps</h3>
<p>
	Starting with version 3.13.0, a new way of passing full userdata across lanes uses a new <tt>__lanesclone</tt> metamethod.
	When a deep userdata is cloned, Lanes calls <tt>__lanesclone</tt> once, in the context of the source lane.</br>
	The call receives the clone and original as light userdata, plus the actual userdata size, as in <tt>clone:__lanesclone(original,size)</tt>, and should perform the actual cloning.</br>
	A typical implementation would look like (BEWARE, THIS CHANGED WITH VERSION 3.16.0):
<table border="1" bgcolor="#FFFFE0" cellpadding="10" style="width:50%"><tr><td><pre>
static int clonable_lanesclone( lua_State* L)
{
	switch( lua_gettop( L))
	{
		case 3:
		{
			struct s_MyClonableUserdata* self = lua_touserdata( L, 1);
			struct s_MyClonableUserdata* from = lua_touserdata( L, 2);
			size_t len = lua_tointeger( L, 3);
			assert( len == sizeof(struct s_MyClonableUserdata));
			*self = *from;
		}
		return 0;

		default:
		(void) luaL_error( L, "Lanes called clonable_lanesclone with unexpected parameters");
	}
	return 0;
}
</pre></td></tr></table>
</p>

<p>
	<b>NOTE</b>: In the event the source userdata has uservalues, it is not necessary to create them for the clone, Lanes will handle their cloning.<br/>
	Of course, more complex objects may require smarter cloning behavior than a simple <tt>memcpy</tt>. Also, the module initialisation code should make each metatable accessible from the module table itself as in:
<table border="1" bgcolor="#FFFFE0" cellpadding="10" style="width:50%"><tr><td><pre>
int luaopen_deep_test(lua_State* L)
{
	luaL_newlib( L, deep_module);

	// preregister the metatables for the types we can instanciate so that Lanes can know about them
	if( luaL_newmetatable( L, "clonable"))
	{
		luaL_setfuncs( L, clonable_mt, 0);
		lua_pushvalue(L, -1);
		lua_setfield(L, -2, "__index");
	}
	lua_setfield(L, -2, "__clonableMT"); // actual name is not important

	if( luaL_newmetatable( L, "deep"))
	{
		luaL_setfuncs( L, deep_mt, 0);
		lua_pushvalue(L, -1);
		lua_setfield(L, -2, "__index");
	}
	lua_setfield(L, -2, "__deepMT"); // actual name is not important

	return 1;
}
</pre></td></tr></table>
</p>

<p>
	Then a new clonable userdata instance can just do like any non-Lanes aware userdata, as long as its metatable contains the aforementionned <tt>__lanesclone</tt> method.
<table border="1" bgcolor="#FFFFE0" cellpadding="10" style="width:50%"><tr><td><pre>
int luaD_new_clonable( lua_State* L)
{
	lua_newuserdata( L, sizeof( struct s_MyClonableUserdata));
	luaL_setmetatable( L, "clonable");
	return 1;
}
</pre></td></tr></table>
</p>

<h3 id="deep_userdata">Deep userdata in your own apps</h3>

<p>
	The mechanism Lanes uses for sharing Linda handles between separate Lua states can be used for custom userdata as well. Here's what to do.
</p>

<ol>
	<li>
		Provide an <i>identity function</i> for your userdata, in C. This function is used for creation and deletion of your deep userdata (the shared resource), and for making metatables for the state-specific proxies for accessing it. The prototype is
		<table border="1" bgcolor="#E0E0FF" cellpadding="10" style="width:50%"><tr><td><pre>	void* idfunc( lua_State* L, DeepOp op_);</pre></td></tr></table>
		<tt>op_</tt> can be one of:
		<ul>
			<li><tt>eDO_new</tt>: requests the creation of a new object, whose pointer is returned. Starting with version 3.13.0, object should embed <tt>DeepPrelude</tt> structure as header and initialize its <tt>magic</tt> member with the current <tt>DEEP_VERSION</tt>.</li>
			<li><tt>eDO_delete</tt>: receives this same pointer on the stack as a light userdata, and should cleanup the object.</li>
			<li><tt>eDO_metatable</tt>: should build a metatable for the object. Don't cache the metatable yourself, Lanes takes care of it (<tt>eDO_metatable</tt> should only be invoked once per state). Just push the metatable on the stack.</li>
			<li><tt>eDO_module</tt>: requests the name of the module that exports the idfunc, to be returned. It is necessary so that Lanes can require it in any lane state that receives a userdata. This is to prevent crashes in situations where the module could be unloaded while the idfunc pointer is still held.</li>
		</ul>
		Take a look at <tt>linda_id</tt> in <tt>lanes.c</tt> or <tt>deep_test_id</tt> in <tt>deep_test.c</tt>.
	</li>
	<li>Include <tt>"deep.h"</tt> and either link against Lanes or statically compile <tt>compat.c deep.c tools.c universe.c</tt> into your module if you want to avoid a runtime dependency for users that will use your module without Lanes.
	<li>Instanciate your userdata using <tt>luaG_newdeepuserdata()</tt>, instead of the regular <tt>lua_newuserdata()</tt>. Given an <tt>idfunc</tt>, it sets up the support structures and returns a state-specific proxy userdata for accessing your data. This proxy can also be copied over to other lanes.</li>
	<li>Accessing the deep userdata from your C code, use <tt>luaG_todeep()</tt> instead of the regular <tt>lua_touserdata()</tt>.</li>
</ol>

<p>
	Deep userdata management will take care of tying to <tt>__gc</tt> methods, and doing reference counting to see how many proxies are still there for accessing the data. Once there are none, the data will be freed through a call to the <tt>idfunc</tt> you provided.
</p>

<p>
	Deep userdata in transit inside keeper states (sent in a linda but not yet consumed) don't call <tt>idfunc(eDO_delete)</tt> and aren't considered by reference counting. The rationale is the following:
	<br />
	If some non-keeper state holds a deep userdata for some deep object, then even if the keeper collects its own deep userdata, it shouldn't be cleaned up since the refcount is not 0.
	<br />
	OTOH, if a keeper state holds the last deep userdata for some deep object, then no lane can do actual work with it. Deep userdata's <tt>idfunc()</tt> is never called from a keeper state.
	<br />
	Therefore, Lanes can just call <tt>idfunc(eDO_delete)</tt> when the last non-keeper-held deep userdata is collected, as long as it doesn't do the same in a keeper state after that, since any remaining deep userdata in keeper states now hold stale pointers.
</p>

<p>
	<b>NOTE</b>: The lifespan of deep userdata may exceed that of the Lua state that created it. The allocation of the data storage should not be tied to the Lua state used. In other words, use <tt>malloc()</tt>/<tt>free()</tt> or similar memory handling mechanism.
</p>


<h3>Lane handles don't travel</h3>

<p>
	Lane handles are not implemented as deep userdata, and cannot thus be copied across lanes. This is intentional; problems would occur at least when multiple lanes were to wait upon one to get ready. Also, it is a matter of design simplicity.
</p>

<p>
	The same benefits can be achieved by having a single worker lane spawn all the sublanes, and keep track of them. Communications to and from this lane can be handled via a Linda.
</p>


<h3>Beware with print and file output</h3>

<p>
	In multithreaded scenarios, giving multiple parameters to <tt>print()</tt> or <tt>file:write()</tt> may cause them to be overlapped in the output, something like this:

<table border="1" bgcolor="#FFFFE0" cellpadding="10" style="width:50%"><tr><td><pre>
	A:  print( 1, 2, 3, 4 )
	B:  print( 'a', 'b', 'c', 'd' )

	1   a   b   2   3   c   d   4
</pre></td></tr></table>

	Lanes does not protect you from this behaviour. The thing to do is either to concentrate your output to a certain lane per stream, or to concatenate output into a single string before you call the output function.
</p>


<h3 id="performance">Performance considerations</h3>

<p>
	Lanes is about making multithreading easy, and natural in the Lua state of mind. Expect performance not to be an issue, if your program is logically built. Here are some things one should consider, if best performance is vital:
</p>

<p>
	<ul>
		<li>Data passing (parameters, upvalues, Linda messages) is generally fast, doing two binary state-to-state copies (from source state to hidden state, hidden state to target state). Remember that not only the function you specify but also its upvalues, their upvalues, etc. etc. will get copied.</li>
		<li>Lane startup is fast (1000's of lanes a second), depending on the number of standard libraries initialized. Initializing all standard libraries is about 3-4 times slower than having no standard libraries at all. If you throw in a lot of lanes per second, make sure you give them minimal necessary set of libraries.</li>
		<li>Waiting Lindas are woken up (and execute some hidden Lua code) each time <u>any</u> key in the Lindas they are waiting for are changed. This may give essential slow-down (not measured, just a gut feeling) if a lot of Linda keys are used. Using separate Linda objects for logically separate issues will help (which is good practise anyhow).</li>
		<li>Linda objects are light. The memory footprint is two OS-level signalling objects (<tt>HANDLE</tt> or <tt>pthread_cond_t</tt>) for each, plus one C pointer for the proxies per each Lua state using the Linda. Barely nothing.</li>
		<li>Timers are light. You can probably expect timers up to 0.01 second resolution to be useful, but that is very system specific. All timers are merged into one main timer state (see <tt>timer.lua</tt>); no OS side timers are utilized.</li>
		<li>If you are using a lot of Linda objects, it may be useful to try having more of these keeper states. By default, only one is used (see <a href="#initialization"><tt>lanes.configure()</tt></a>).</li>
</ul>
</p>


<h3 id="cancelling_cancel">Cancelling cancel</h3>

<p>
	Cancellation of lanes uses the Lua error mechanism with a special lightuserdata error sentinel.
	If you use <tt>pcall</tt> in code that needs to be cancellable from the outside, the special error might not get through to Lanes, thus preventing the Lane from being cleanly cancelled.
	You should throw any lightuserdata error further.
</p>

<p>
	This system can actually be used by application to detect cancel, do your own cancellation duties, and pass on the error so Lanes will get it. If it does not get a clean cancellation from a lane in due time, it may forcefully kill the lane.
</p>

<p>
	The sentinel is exposed as <tt>lanes.cancel_error</tt>, if you wish to use its actual value.
</p>



<!-- change log +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>
<h2 id="changes">Change log</h2>

<p>
	See CHANGES.
</p>

<!-- footnotes +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr/>

<p>
	For feedback, questions and suggestions:
	<ul>
		<li><A HREF="http://github.com/LuaLanes/lanes">Lanes @ GitHub</A></li>
		<li><A HREF="mailto:bnt.germain@gmail.com">the maintainer</A></li>
		<li><A HREF="http://www.lua.org/lua-l.html">the lua mailing list</A></li>
	</ul>
</p>

</body>
</html>